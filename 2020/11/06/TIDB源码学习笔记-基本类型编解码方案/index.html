<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>TIDB源码学习笔记-基本类型编解码方案 | 九五之猪</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/header.png)">
        <div class='av-pic' style="background-image: url(/assets/pig.jpg)">
        </div>
    </section>
    <section class='menu'>
        <div>九五之猪</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/tags/" class="Btn">
              <li>Tags</li>
            </a>  
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/haxisnake">
                    <img src="/assets/github.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>TIDB源码学习笔记-基本类型编解码方案</h1>
    </header>

    <section>
      <h1 id="TIDB基本类型的编码方案"><a href="#TIDB基本类型的编码方案" class="headerlink" title="TIDB基本类型的编码方案"></a>TIDB基本类型的编码方案</h1><p>TIDB在编码不同的数据类型时会在编码前部添加一个字节的Flag用来区分不同的编码方案。同时，TIDB支持具有Memcomparable特性的编码，Memcomparable是指保证编码前和编码后的比较关系不变。在TIDB中，对于Key的编码都是要求Memcomparable的，而对于Value的编码则不要求Memcomparable，可以采用更节省空间的编码方案。</p>
<p>在进行编码前，会先依据数据类型预先申请一定尺寸的byte，然后再进行编码。</p>
<p>如下是目前的Flag，用于标识不同的编码方案<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    NilFlag          <span class="keyword">byte</span> = <span class="number">0</span></span><br><span class="line">    bytesFlag        <span class="keyword">byte</span> = <span class="number">1</span></span><br><span class="line">    compactBytesFlag <span class="keyword">byte</span> = <span class="number">2</span></span><br><span class="line">    intFlag          <span class="keyword">byte</span> = <span class="number">3</span></span><br><span class="line">    uintFlag         <span class="keyword">byte</span> = <span class="number">4</span></span><br><span class="line">    floatFlag        <span class="keyword">byte</span> = <span class="number">5</span></span><br><span class="line">    decimalFlag      <span class="keyword">byte</span> = <span class="number">6</span></span><br><span class="line">    durationFlag     <span class="keyword">byte</span> = <span class="number">7</span></span><br><span class="line">    varintFlag       <span class="keyword">byte</span> = <span class="number">8</span></span><br><span class="line">    uvarintFlag      <span class="keyword">byte</span> = <span class="number">9</span></span><br><span class="line">    jsonFlag         <span class="keyword">byte</span> = <span class="number">10</span></span><br><span class="line">    maxFlag          <span class="keyword">byte</span> = <span class="number">250</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>下表是数据类型与Flag的对应关系以及相应的编码尺寸计算方法，具体的编码方案会在后续一一展开。</p>
<img src="/2020/11/06/TIDB源码学习笔记-基本类型编解码方案/encode.png">
<h1 id="INT64"><a href="#INT64" class="headerlink" title="INT64"></a>INT64</h1><h2 id="comparable"><a href="#comparable" class="headerlink" title="comparable"></a>comparable</h2><p>这种方式保证编码后的二进制排序结果与编码前的是完全相同的。</p>
<p>编码方法:  uint64(num) ^ signMask </p>
<p>const signMask uint64 = 0x8000000000000000</p>
<table>
<thead>
<tr>
<th>signed int</th>
<th>binary</th>
<th>after code</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0000 0000 0000 0001</td>
<td>1000 0000 0000 0001</td>
</tr>
<tr>
<td>0</td>
<td>0000 0000 0000 0001</td>
<td>1000 0000 0000 0001</td>
</tr>
<tr>
<td>-1</td>
<td>1111 1111 1111 1111</td>
<td>0111 1111 1111 1111</td>
</tr>
<tr>
<td>-2</td>
<td>1111 1111 1111 1110</td>
<td>0111 1111 1111 1110</td>
</tr>
</tbody>
</table>
<h2 id="uncomparable"><a href="#uncomparable" class="headerlink" title="uncomparable:"></a>uncomparable:</h2><p>这种方法不能保证编码后是严格有序的。</p>
<p>编码方法: PutVarint函数</p>
<p>PutVarint:</p>
<p>步骤一：左移去掉符号位,如果是负数则对移位后的数取反</p>
<p>步骤二：将得到的数字从低到高每七位放入一个字节中，字节的第一位表示是否有后续字节。</p>
<p>举例：</p>
<table>
<thead>
<tr>
<th>原始数据</th>
<th>16进制表示</th>
<th>步骤一结果</th>
<th>步骤二结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0x1</td>
<td>0x02</td>
<td>0x02</td>
</tr>
<tr>
<td>-1</td>
<td>0xffffffffffffffff</td>
<td>0x01</td>
<td>0x01</td>
</tr>
<tr>
<td>128</td>
<td>0x80</td>
<td>0x0100</td>
<td>0x8002</td>
</tr>
<tr>
<td>127</td>
<td>0x7f</td>
<td>0xfe</td>
<td>0xfe01</td>
</tr>
</tbody>
</table>
<h1 id="Uint64"><a href="#Uint64" class="headerlink" title="Uint64"></a>Uint64</h1><h2 id="comparable-1"><a href="#comparable-1" class="headerlink" title="comparable"></a>comparable</h2><p>直接写入二进制</p>
<h2 id="uncomparable-1"><a href="#uncomparable-1" class="headerlink" title="uncomparable"></a>uncomparable</h2><p>将二进制表示从低到高每七位放入一个字节中，字节的第一位表示是否有后续字节，其实就是去掉int64的uncomparable中符号处理那一步后剩下的步骤。</p>
<h1 id="Float32-Float64"><a href="#Float32-Float64" class="headerlink" title="Float32 Float64"></a>Float32 Float64</h1><p>Go的浮点数是按照IEEE 754浮点数标准存储的，TIDB直接对二进制表示进行操作</p>
<p>将正浮点数的符号位置1，将负浮点数的二进制表示按位取反</p>
<p>这样编码后的二进制是先比较符号位，再比较指数位，最后比较小数位，就可以保证编码值是升序的。对于负浮点数的比较因为是进行了取反，所以也能保证是升序的。如果要降序只要将编码值取反即可。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeFloatToCmpUint64</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    u := math.Float64bits(f)</span><br><span class="line">    <span class="keyword">if</span> f &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        u |= signMask</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        u = ^u </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Byte"><a href="#Byte" class="headerlink" title="Byte"></a>Byte</h1><h2 id="comparable-2"><a href="#comparable-2" class="headerlink" title="comparable"></a>comparable</h2><p>[group1][marker1]…[groupN][markerN]</p>
<p>group 是补零之后的8字节切片</p>
<p>markder = 0xFF - 补零数量</p>
<p>举例:</p>
<pre><code>[] -&gt; [0, 0, 0, 0, 0, 0, 0, 0, 247]

[1, 2, 3] -&gt; [1, 2, 3, 0, 0, 0, 0, 0, 250]

[1, 2, 3, 0] -&gt; [1, 2, 3, 0, 0, 0, 0, 0, 251]

[1, 2, 3, 4, 5, 6, 7, 8] -&gt; [1, 2, 3, 4, 5, 6, 7, 8, 255, 0, 0, 0, 0, 0, 0, 0, 0, 247]
</code></pre><h2 id="uncomparable-2"><a href="#uncomparable-2" class="headerlink" title="uncomparable"></a>uncomparable</h2><p>数据长度 + 实际数据的二进制</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>如果有排序规则，则使用排序规则得到的Bytes，否则直接用String本身的Bytes<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encodeString</span><span class="params">(b []<span class="keyword">byte</span>, val types.Datum, comparable <span class="keyword">bool</span>)</span> []<span class="title">byte</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> collate.NewCollationEnabled() &amp;&amp; comparable &#123;</span><br><span class="line">        <span class="keyword">return</span> encodeBytes(b, collate.GetCollator(val.Collation()).Key(val.GetString()), <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> encodeBytes(b, val.GetBytes(), comparable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="MysqlTime"><a href="#MysqlTime" class="headerlink" title="MysqlTime"></a>MysqlTime</h1><p>先进行时区转化，全部转换为UTC时区后将Time转为uint64，再以uint64的形式进行编码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ToPackedUint encodes Time to a packed uint64 value.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    1 bit  0</span></span><br><span class="line"><span class="comment">//   17 bits year*13+month   (year 0-9999, month 0-12)</span></span><br><span class="line"><span class="comment">//    5 bits day             (0-31)</span></span><br><span class="line"><span class="comment">//    5 bits hour            (0-23)</span></span><br><span class="line"><span class="comment">//    6 bits minute          (0-59)</span></span><br><span class="line"><span class="comment">//    6 bits second          (0-59)</span></span><br><span class="line"><span class="comment">//   24 bits microseconds    (0-999999)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   Total: 64 bits = 8 bytes</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   0YYYYYYY.YYYYYYYY.YYdddddh.hhhhmmmm.mmssssss.ffffffff.ffffffff.ffffffff</span></span><br></pre></td></tr></table></figure></p>
<h1 id="MysqlDuration"><a href="#MysqlDuration" class="headerlink" title="MysqlDuration"></a>MysqlDuration</h1><p>duration可能有负值，所以无法直接用string来进行编码，采用的是同Int comparable相同的编码。</p>
<h1 id="MysqlDecimal"><a href="#MysqlDecimal" class="headerlink" title="MysqlDecimal"></a>MysqlDecimal</h1><p>编码方式： precision + frac + WriteBin函数</p>
<p>WriteBin: 每 9 位十进制数字包装成 4 个字节. 其中整数和小数部分分别确定所需的存储空间. 如果数字位数为 9 的倍数, 则每 9 位十进制数字各采用 4 个字节进行存储, 对于剩余不足 9 位的数字, 所需的存储空间如下表所示：</p>
<table>
<thead>
<tr>
<th>剩余数字位数</th>
<th>存储所需字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1-2</td>
<td>1</td>
</tr>
<tr>
<td>3-4</td>
<td>2</td>
</tr>
<tr>
<td>5-6</td>
<td>3</td>
</tr>
<tr>
<td>7-9</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<p>1234567890.1234</p>
<p>以9位数字以及小数点为边界，可将decimal类型拆分为如下所示：</p>
<pre><code>1 234567890 123400000
</code></pre><p>假设存储位数为有效位数为14，小数位为4，使用16进制表示为三部分：</p>
<pre><code>00-00-00-01  0D-FB-38-D2  07-5A-EF-40
</code></pre><p>现在，中间部分已经是被填满，它存储了9位的十进制数字：</p>
<pre><code>............  0D-FB-38-D2  ............
</code></pre><p>第一部分只有一个十进制数字，所以我们可以只用一个字节来存储，而不必浪费四个字节：</p>
<pre><code>01 0D-FB-38-D2 ............
</code></pre><p>现在，最后一部分，它是123400000，我们可以用两个字节来存储：</p>
<pre><code>01 0D-FB-38-D2 04-D2
</code></pre><p>因此，我们将一个12个字节的数字使用7字节进行了表示，现在需要将最高位反转来得到最后的结果：</p>
<pre><code>81 0D FB 38 D2 04 D2
</code></pre><p>如果要表示 -1234567890.1234，需要将各个位取反：</p>
<pre><code>7E F2 04 C7 2D FB 2D
</code></pre><p>最高位反转，是为了保证有相同有效位数和有效小数位的DECIMAL类型编码后的二进制具有comparable特性。原因如下：</p>
<p>首先，最高位的置不影响原先数值的表示，因为不管第一部分剩多少位数字，它永远不会取到最高位，所以正数的DECIMAL类型的comparable可以得到保证。</p>
<p>其次，通过最高位置1再反转的形式，可以保证所有的负数的二进制编码都小于正数的二进制编码，即保证了正数和负数二进制编码之间的comparable。</p>
<p>最后，负数编码的comparable则是通过将正数编码所有位取反保证的。</p>
<h1 id="MysqlEnum-MysqlSet-MysqlBit-BinaryLiteral"><a href="#MysqlEnum-MysqlSet-MysqlBit-BinaryLiteral" class="headerlink" title="MysqlEnum MysqlSet MysqlBit BinaryLiteral"></a>MysqlEnum MysqlSet MysqlBit BinaryLiteral</h1><p>通过各自的ToNumber或者ToInt方法转化为uint64进行编码</p>
<h1 id="MysqlJSON"><a href="#MysqlJSON" class="headerlink" title="MysqlJSON"></a>MysqlJSON</h1><p>TypeCode + Value</p>
<p>TypeCode:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeCodeObject indicates the JSON is an object.</span></span><br><span class="line">TypeCodeObject TypeCode = <span class="number">0x01</span></span><br><span class="line"><span class="comment">// TypeCodeArray indicates the JSON is an array.</span></span><br><span class="line">TypeCodeArray TypeCode = <span class="number">0x03</span></span><br><span class="line"><span class="comment">// TypeCodeLiteral indicates the JSON is a literal.</span></span><br><span class="line">TypeCodeLiteral TypeCode = <span class="number">0x04</span></span><br><span class="line"><span class="comment">// TypeCodeInt64 indicates the JSON is a signed integer.</span></span><br><span class="line">TypeCodeInt64 TypeCode = <span class="number">0x09</span></span><br><span class="line"><span class="comment">// TypeCodeUint64 indicates the JSON is a unsigned integer.</span></span><br><span class="line">TypeCodeUint64 TypeCode = <span class="number">0x0a</span></span><br><span class="line"><span class="comment">// TypeCodeFloat64 indicates the JSON is a double float number.</span></span><br><span class="line">TypeCodeFloat64 TypeCode = <span class="number">0x0b</span></span><br><span class="line"><span class="comment">// TypeCodeString indicates the JSON is a string.</span></span><br><span class="line">TypeCodeString TypeCode = <span class="number">0x0c</span></span><br><span class="line"></span><br><span class="line">Value []<span class="keyword">byte</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>NilFlag</p>
<h2 id="MinNotNull"><a href="#MinNotNull" class="headerlink" title="MinNotNull"></a>MinNotNull</h2><p>bytesFlag</p>
<h2 id="MaxValue"><a href="#MaxValue" class="headerlink" title="MaxValue"></a>MaxValue</h2><p>maxFlag</p>
<h1 id="编码模块位置"><a href="#编码模块位置" class="headerlink" title="编码模块位置"></a>编码模块位置</h1><ul>
<li>util/codec</li>
<li>tablecodec</li>
<li>util/rowcodec</li>
</ul>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2020-11-06T08:59:13.000Z" itemprop="datePublished">
              2020-11-06
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/TIDB/">TIDB</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/Golang/">Golang</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2020 - HaxiSnake </div>
    <div>
        <span>
            Powered by <a href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>